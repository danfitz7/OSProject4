Notes

We have three levels in the heirarchy:
	RAM (25 vAddrs)
	SSD (100 vAddrs)
	HDD (1000 vAddrs)


We use a page table of 100 entries to contains information about each page on the system.

/***********************************/
Dealing with page faults
	1. Determine the location of the data in secondary storage.
	2. Obtain an empty page frame in RAM to use as a container for the data.
	3. Load the requested data into the available page frame.
	4. Update the page table to refer to the new page frame.
	5. Return control to the program, transparently retrying the instruction that caused the page fault.

If we run allocate 25 times, it will immediately add 25 entries to the RAM array and make 25 entries in the page table. 
If we allocate more than 25 times, but less than 125 times, the system will swap old values in RAM to the SSD and bring new items into RAM.
If we allocate more than 125 times but less than 1000 times without freeing, then the system will swap old values in RAM into the SSD and then old values in the SSD into the HDD.
If we allocate more than 1000 times without freeing, system will alert.
If we run free, we delete any instance of the page anywhere on the system and free the spot in the page table

/***********************************/
Determining if a memory hierarchy is full

Option 1:
	Iterate through page table and increment a counter when we see an allocated page in a certain level

Option 2:
	Keep a counter for the number of items in each level and increment/decrement as needed

/***********************************/
page table holds a thousand entries
to determine if memory is full, we can iterate through the page table and stop when a page has allocated (valid) == 0.

The lower levels of the memory hierarchy are going to stay as full as possible. 

When we add a page to the table, store a pointer to its location in the memory hierarchy. When we free, we just have to "unallocate" any reference to this item in memory